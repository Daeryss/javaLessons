https://refactoring.guru/ru/design-patterns/chain-of-responsibility

Client – код который конструирует цепочку и вызывает обработку события
Handler (BanknoteHandler) - объявляет интерфейс для обработки запросов.
Содержит базовую логику по вызову запросов в цепочке
ConcreteHandler (TenRubleHandler) - обрабатывает запрос, за который
отвечает, если ConcreteHandler не может обработать текущий запрос,
вызывается Handler базового класса, который вызывает следующий обработчик
из цепочки.

Достоинства:
Ослабление связанности
Дополнительная гибкость при распределении обязанностей между объектами
Недостатки:
Обработка запроса не гарантирована
Особенности:
Совместное использование с Composite, Builder,
Использование нескольких переходов

            ====Структура====
1. Обработчик определяет общий для всех конкретных обработчиков интерфейс.
Обычно достаточно описать единственный метод обработки запросов, но
иногда здесь может быть объявлен и метод выставления следующего обработчика.

2. Базовый обработчик — опциональный класс, который позволяет избавиться от
дублирования одного и того же кода во всех конкретных обработчиках.

Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в
цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий
обработчик через конструктор или сеттер поля. Также здесь можно реализовать
базовый метод обработки, который бы просто перенаправлял запрос следующему
обработчику, проверив его наличие.

3. Базовый обработчик — опциональный класс, который позволяет избавиться от
дублирования одного и того же кода во всех конкретных обработчиках.

Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в
цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий
обработчик через конструктор или сеттер поля. Также здесь можно реализовать
базовый метод обработки, который бы просто перенаправлял запрос следующему
обработчику, проверив его наличие.

Базовый обработчик — опциональный класс, который позволяет избавиться от
дублирования одного и того же кода во всех конкретных обработчиках.

4. Обычно этот класс имеет поле для хранения ссылки на следующий обработчик
в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий
обработчик через конструктор или сеттер поля. Также здесь можно реализовать
базовый метод обработки, который бы просто перенаправлял запрос следующему
обработчику, проверив его наличие.


            ====Шаги реализации====
1. Создайте интерфейс обработчика и опишите в нём основной метод обработки.

Продумайте, в каком виде клиент должен передавать данные запроса в обработчик.
Самый гибкий способ — превратить данные запроса в объект и передавать его
целиком через параметры метода обработчика.

2. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не дублировать
реализацию метода получения следующего обработчика во всех конкретных обработчиках.

Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки.
Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты
обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку
цепочек, можете добавить и сеттер для поля.

Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему
объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от
подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь
к родительской реализации метода.

3. Один за другим создайте классы конкретных обработчиков и реализуйте в
них методы обработки запросов. При получении запроса каждый обработчик
должен решить:

Может ли он обработать запрос или нет?
Следует ли передать запрос следующему обработчику или нет?

4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на
свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем
случае цепочки собираются фабричными объектами, опираясь на конфигурацию
приложения или параметры окружения.

5. Клиент может посылать запросы любому обработчику в цепи, а не только
первому. Запрос будет передаваться по цепочке до тех пор, пока какой-то
обработчик не откажется передавать его дальше, либо когда будет
достигнут конец цепи.
