https://refactoring.guru/ru/design-patterns/factory-method

    Назначение - отделяет интерфейс для создания объекта, но
оставляет подклассам решение о том, какой класс инстанцировать.
Фабричный метод позволяет классу делегировать создание объектов
подклассам

    Применимость:
-класса заранее извесстно, объекты каких классов ему нужно создать,
тк возможны варианты реализации
-класс спроектирован так, чтобы объекты, которые он создает,
специфицировались подклассами (спецификация порождаемого объекта
определена в наследниках).
-класс выделяет и делегирует часть своих функций вспомогательному
подклассу. При этом необходимо скрыть его реализацию для достижения
большей гибкости или возможности расширения функциональности.

-КЛАССИЧЕСКИЙ ФАБРИЧНЫЙ МЕТОД является частным случаем шаблонного
метода. Это значит, что фабричный метод привязан к текущей иерархии
типов и не может быть использован повторно в другом контексте

-СТАТИЧЕСКИ ФАБРИЧНЫЙ МЕТОД является самой простой формой.
Статический метод создания позволяет обойти ограничения конструкторов.
Например, тип создаваемого объекта может зависеть от аргументов методаб
экземпляр может возвращаться из кэша, а не создаваться заново или же
фабричный метод может быть асинхронным.

-ПОЛИМОРФНЫЙ ФАБРИЧНЫЙ МЕТОД является стратегией создания
экземпляров некоторого семейства типов, что позволяет использовать одну
фабрику в разных контекстах. Тип создаваемого объекта определяется типом
фабрики и обычно не зависит от аргументов фабричного метода.



Фабричный метод — это порождающий паттерн проектирования,
который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых
объектов.

1. Продукт определяет общий интерфейс объектов, которые
может произвести создатель и его подклассы.

2. Конкретные продукты содержат код различных продуктов.
Продукты будут отличаться реализацией, но интерфейс у них
будет общий.

3. Создатель объявляет фабричный метод, который должен
возвращать новые объекты продуктов. Важно, чтобы тип
результата совпадал с общим интерфейсом продуктов.

4. Конкретные создатели по-своему реализуют фабричный метод,
производя те или иные конкретные продукты.

5. Фабричный метод не обязан всё время создавать новые объекты.
Его можно переписать так, чтобы возвращать существующие объекты
из какого-то хранилища или кэша.

Зачастую фабричный метод объявляют абстрактным, чтобы
заставить все подклассы реализовать его по-своему.
Но он может возвращать и некий стандартный продукт.

Несмотря на название, важно понимать, что создание продуктов
не является единственной функцией создателя. Обычно он
содержит и другой полезный код работы с продуктом.
Аналогия: большая софтверная компания может иметь центр подготовки
программистов, но основная задача компании — создавать программные
продукты, а не готовить программистов.

            ===Шаги реализации===
1. Приведите все создаваемые продукты к общему интерфейсу.

2. В классе, который производит продукты, создайте пустой
фабричный метод. В качестве возвращаемого типа укажите общий
интерфейс продукта.

3. Затем пройдитесь по коду класса и найдите все участки,
создающие продукты. Поочерёдно замените эти участки вызовами
фабричного метода, перенося в него код создания различных продуктов.

В фабричный метод, возможно, придётся добавить несколько параметров,
контролирующих, какой из продуктов нужно создать.

На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе.
В нём будет жить большой условный оператор, выбирающий класс
создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.

4. Для каждого типа продуктов заведите подкласс и переопределите
в нём фабричный метод. Переместите туда код создания
соответствующего продукта из суперкласса.

5. Если создаваемых продуктов слишком много для существующих
подклассов создателя, вы можете подумать о введении параметров
в фабричный метод, которые позволят возвращать различные продукты
в пределах одного подкласса.

Например, у вас есть класс Почта с подклассами АвиаПочта и
НаземнаяПочта, а также классы продуктов Самолёт, Грузовик и
Поезд. Авиа соответствует Самолётам, но для НаземнойПочты
есть сразу два продукта. Вы могли бы создать новый подкласс
почты для поездов, но проблему можно решить и по-другому.
Клиентский код может передавать в фабричный метод НаземнойПочты
аргумент, контролирующий тип создаваемого продукта.

6. Если после всех перемещений фабричный метод стал пустым, можете
сделать его абстрактным. Если в нём что-то осталось — не беда,
это будет его реализацией по умолчанию.

        ===Преимущества и недостатки===
Преимущества:
 Избавляет класс от привязки к конкретным классам продуктов.
 Выделяет код производства продуктов в одно место, упрощая поддержку кода.
 Упрощает добавление новых продуктов в программу.
 Реализует принцип открытости/закрытости.

Недостатки:
 Может привести к созданию больших параллельных иерархий классов,
 так как для каждого класса продукта надо создать свой подкласс создателя.