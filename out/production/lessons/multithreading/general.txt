Ключевые слова и методы:
synchronized - концепция монитора
volatile - указывает, что взаимодействие с переменной в памяти должно происходить минуя кэши процессора (processor cash memory)
.wait()/wait(12) - освобождает монитор и становится на "паузу", вызывается у объекта-монитора, когда он занят, внутри блока synchronized
.notify()/.notifyAll() - снимает с паузы только когда монитор занят, те внутри блока synchronized
.join()/.join(123) - приостанавливает работу потока поак другой поток не выполнит свою работу/на определенное время (мс)
CowntDownLatch — позволяет стартовать нескольким потокам одновременно (один раз)
CyclicBarrier - позволяет стартовать нескольким потокам одновременно (цикличноб допустим потоки копяться и каждые 5с стартуют одновременно)
Semaphore - Примитив синхронизации позволяет определенному количеству потоков исполнять критическую секцию кода, которая защищена семафором.
Exchanger  — точка синхронизации, которая позволяет двум потокам обмениваться значениями.
Daemon – фоновый поток.
Deadlock — это ошибка, которая происходит когда потоки имеют циклическую зависимость от пары синхронизированных объектов.
thread dump - снимок состояния системы, показывает имеющиеся потоки



Поток можно создать двумя способами:
-расширив класс Thread
-реализовав интерфейс Runnable
в обоих случаях следует переопределить метод run() в котором находится весь основной код.
Запуск потока
разница между .run() start() в том, что
.run() - выполняется в том же потоке (main()), что создал его, как метод,
.start() - запускает новый поток.
interrupt(); - останавливает поток (нужна обработка try/catch InterruptedException)
Daemon в широком значении – фоновая программа.
.setDaemon(true/false) - устанавливает значение
.isDaemon() - boolean


* объект текущего потока можно плучить из Thread.currentThread()
.getName(), setName() - олучение и изменение имени потока
стандартный формат для имени потока thread-N,
для пула потоков - pool-N-thread-M (N - num of pool, M- num of thread in pool)

Приоритет потоков
у потоков есть приоритет от 1 до 10. Приоритет main - 5.
приоритет порожденных потоков равен приоритету родительского.
изменить можно при помощи.setPriority(int).
Поток с большим приоритетом будет иметь больше процессорного времению
Если потоки имеют одинаковый приоритет, то решение будет принято при помощи
алгоритма-планировщика.
Thread.MIN_PRIORITY - 1
Thread.NORM_PRIORITY - 5
Thread.MAX_PRIORITY - 10

для прерывания работы потока используется метод .interrupt()
также есть boolean .isInterrupted() - возвращает значение флага и не изменяет его
.interrupted() - возвращает значение флага и устанавливает его значение в false.
Если флаг interrupted был true, то в первый раз вернет true, в последующие false
есть блокирующие sleep(), wait(), join() методы.
 Если поток был прерван пока выполнял не блокирующие вычисления, они не будут
 прерваны незамедлительно, однако поток уже отмечен, как прерванный, а любая слудующая блокировка
 выкинет InterruptedException
 для этого следует обрабатывать в методе run()

 synchronized - концепция монитора, есть у каждого Object, содержит 4 поля:
 locked - boolean, показывает захвачен монитор или нет
 owned - типа Thread, в это поле записывается поток, который захватил данный монитор;
 blocked set - в это множество попадают потоки, которые не смогли захватить блокировку, или поток, который выходит из состояния wait;
 wait set - в это множество попадают потоки, для которых был вызван wait.

 volatile - указывает, что взаимодействие с переменной
 в памяти должно происходить минуя кэши процессора (processor cash memory)

 Semaphore
 Примитив синхронизации позволяет определенному количеству потоков исполнять критическую секцию
 кода, которая защищена семафором. Когда создается семафор, в конструктор передается количество
 пропусков. Во время захвата семафора количество допустимых пропусков уменьшается. Когда семафор
 освобождается, количество пропусков увеличивается. Также в методе захвата семафора можно указать,
 какое количество пропусков возьмет поток. В методе освобождения семафора можно указать количество
 пропусков, которое будет возвращено: это количество не может быть больше, чем захваченное количество
 пропусков.
 Когда вторым параметром в конструктор передается true, потоки, которые ожидают получение пропуска,
 т. е. хотят войти в критическую секцию, выстраиваются в очередь. Т. е. вместо blocking set
 используется очередь по типу FIFO.

 Exchanger  — точка синхронизации, которая позволяет двум потокам обмениваться значениями. При
 создании экземпляра этого объекта указывается тип объекта, которым будут обмениваться потоки.
 У объекта этого класса есть метод exchange, принимающий значение которое надо передать другому потоку.
 Метод возвращает значение, которые другой поток передал текущему. Когда поток вызывает метод exchange(),
 а другой поток не готов к обмену значениями, текущий поток переходит в состояние WAITING. Отметим, что
 этот класс стоит использовать для обмена значениями между двумя потоками. Если один Exchanger используется
 только одним потоком или количество потоков-пользователей больше двух, то какой-то поток будет в состоянии
 WAITING бесконечно долго, пока не остановится программа. Если первый поток подготовил значение, и метод
 exchange выполняет второй поток, то второй поток после выполнения метода не блокируется. Также у класса
 есть перегруженный метод exchange, который принимает время, которое поток будет находится в состоянии
 WAITING. По истечении этого времени генерируется проверяемое исключение TimeOutException.

 Phaser — самый сложный синхронизатор, который, тем не менее, обладает самым большим функционалом.
 Phaser похож на CountDownLatch, он позволяет синхронизировать несколько потоков, причем их количество
 может меняться в разных фазах. Phaser — блокировка, которую можно переиспользовать. Работа Phaser
 состоит из выполнения фаз — выполнив очередную фазу, поток вызывает у Phaser метод arriveAndAwaitAdvance().
 Работу Phaser можно представить как цепочку заданий или фаз, в каждой из которых может принимать участие
 разное количество потоков.

 Чтобы текущий поток участвовал в определенной фазе вычислений, он регистрируется вызовом метода register()
 у объекта Phaser. После того как один поток закончит свои вычисления и захочет подождать остальные потоки,
 он вызывает метод arriveAndAwaitAdvance() у блокировки. Это блокирующий метод. Поток продолжит свое выполнение,
 когда количество потоков, вызвавших метод arriveAndAwaitAdvance(), станет равно количеству зарегистрированных
 потоков, которые вызвали метод register(). Если поток не хочет участвовать в следующей фазе выполнения с
 использованием Phaser, следует вызвать метод arriveAndDeregister(). Если поток выполнил свои вычисления,
 но не хочет ожидать, пока другие потоки завершат этап своих вычислений, поток должен вызвать метод arrive().

            ===Пул потоков===
 Пул потоков — своего рода контейнер, в котором содержатся потоки, которые могут выполнять задачи, и после
 выполнения одной самостоятельно переходить к следующей.

 Вторая причина создания пулов потоков — возможность разделить объект, выполняющий код, и непосредственно код
 задачи, которую необходимо выполнить. Использование пула потоков обеспечивает лучший контроль создания потоков
 и экономит ресурсы создания потоков. Также использование пула потоков упрощает разработку многопоточных программ,
 упрощая создание и манипулирование потоками. За созданием и управлением пулом потоков отвечают несколько классов
 и интерфейсов, которые называются Executor Framework in Java.

 Deadlock или дедлок или взаимная блокировка — это ошибка, которая происходит когда потоки имеют циклическую
 зависимость от пары синхронизированных объектов. Представьте, что один поток входит в монитор объекта x,
 а другой — объекта y. Если поток в объекте x пытается вызвать любой синхронизированный метод объекта y, а объект y
 в то же самое время пытается вызвать любой синхронизированный метод объекта x, то потоки застрянут в процессе ожидания.
